# ProcessorDocumentation

Documentation for my latest processor designs.

## Introduction & History

The design originates here: https://github.com/ZYSF/gen1cpu which was my "first-generation" processor design, but the documentation in this repository is for my "second-generation" or current design (as of 2022).

Major changes to the implementation/s (which I haven't uploaded fully, at least at this stage) include gradually moving towards an algorithmic/autogenerated design which is already capable of producing 32-bit as well as 64-bit implementations. This means some necessary breaking changes were needed, so I decided to branch the documentation off separately while finalising how to continue developing/releasing future implementations. Other improvements have been made to ease testing.

The contents of this repository is developed from scratch (based on my previous/original designs), and made freely available for whatever purposes (under the terms of "unlicense").

### Breaking Changes/Compatiblity Notes

Firstly there were/are a lot of bugs, so much of the logic shouldn't be expected to work without specific testing of each feature/in each configuration!

Architecturally, though, there is one major breaking change: The `READ32H` and `WRITE32H`/`WRITE32HX` opcodes are moved to better encodings, and are now more accurately-specified for 32-bit mode. This allows for more thorough implementation of the rest of the planned read/write instructions, and also serves to allow easier implementation of 32-/64-bit-neutral programs. A similar change also applies to the `CTRLIN`/`CTRLOUT` instructions, which were previously specialised for either 64-bit or 32-bit models (now the same instructions apply to either).

Other new instructions either fit into previously-unused encodings or only apply to 32-bit mode (which was not fully documented or implemented in the original "gen1cpu").

Besides the new/modifiedinstructions various bugfixes (some of which have been back-ported to the original "simple" codebase), the major version has been bumped up to 2!

Creating a new "major version" within the same architecture allows for the first experiments in backwards-compatibility; Theoretically, code can detect/adapt whether they're running on a "gen1" or "gen2" processor, and (theoretically) code running on a 64-bit "gen2" processor could use existing capabilities to specially patch out the conflicting instructions to create a compatibility mode for (64-bit only) gen1 instructions.

The current version of the processor generator can even backport some fixes and other non-conflicting updates to the "gen1" implementation!

## Design Overview

The overall design is a somewhat-RISC-like system (roughly meaning that instructions typically share common sizing & layouts) and follows from some basic principles:

* The instruction encoding needs to be original, purpose-designed and well-structured, specifically taking effort to ignore any complex operations from proprietary architectures and only implementing instructions as needs arise
     * Besides technical reasons, this serves to isolate the system from any complex intellectual property questions: _The core design (as documented here) is completely free for you to copy/modify/redistribute/etc._ "ProcessorDocumentation", "generation 1", "generation 2" etc. are not used as trademarks either!
* Porting existing compilers is not necessarily worth losing sleep over
     * I've already demonstrated that it's fairly easy to add additional decoding/emulation modes to the processor design
* The system needs to be usable at least for testing purposes in simulators and "cheap" FPGAs (not necessarily _the cheapest_ FPGAs, but at least mid-level ones!)
* The "processor" should be mostly self-reliant, besides obvious memory/IO interfaces (it shouldn't rely on any complex external circuitry or designs for any "core features")
* Core features must include basic system-management and protection features (to ensure that basic system software doesn't need any extra add-ons to manage/debug programs properly)
* The reference implementations (whether 32-bit or 64-bit internally) should be easy to deploy on a simple 32-bit-only memory bus (more-complex bus operations should be optional and emulatable in software)
* Optimisation is not particularly important
** As long as the core design/instruction set itself isn't especially inefficient, the details can always be optimised later!

As a result, some major differences from other systems include:

* Well-written system/testing programs can operate on both 32- and 64-bit implementations from the same executable (without re-compilation)
* C compilers could still be ported to the system, but some features are more suited to specialised/modern programming systems
* Basic exception/interrupt/timer/memory-protection/address-translation features and user-/system-mode switching are built-in, these aren't part of some separate extension or external circuit
* Some features like register protection may be somewhat-unique to the platform
* Aside from the more-complex built-in features, the processor features can easily be scaled down to optimise for only a very minimal set of instructions or scaled up to handle all sorts of custom ISA extensions
* Because performance is not a great immediate concern (so the processor internally can execute each instruction in multiple stages), adding checking/exception-handling at the necessary stages has not been too complex
* There are some specialised I/O features, so basic input & output can be performed without relying on a complex "memory-mapped" bus implementation

## Index of Documents

* [Instruction Set](InstructionSet.md) documents the semantics and encoding of each of the standard instructions
* [Control Registers](ControlRegisters.md) documents the meanings, encodings and indices of the control registers
* [Modes & Exceptions](ModesAndExceptions.md) documents the user-mode/system-mode switching and the meanings of the exception codes
* [Startup & Reset State](StartupAndResetState.md) documents the startup/reset sequence and what state to expect the core to be in at initialisation
* [Addressing Modes](AddressingModes.md) should help to clarify the role of the MMU and the ways in which instructions, memory locations, I/O and control registers are addressed
* [Portability Between 32- & 64-Bit Models](Portability32And64Bit.md) should serve as a design guide to 32-/64-bit variations and a programming reference for writing model-agnostic executables

NOTE: Updated "RISC Emulation" circuitry as in the first generation still exists in the second-generation design but this has been de-prioritised in favour of other features (at least for now), and has been mostly isolated away from the core ISA design (except for the relevant mode-setting & instruction overriding information).
